
const fs = require("fs")
const axios = require("axios")

const HTMLParser = require("node-html-parser")

let counter = 0

const bible = (function(){
    const _getVersions = async (language="en") => {
        versions = {}
        languages = []
        data = HTMLParser.parse((await axios.get("https://www.biblegateway.com/versions")).data)
        data.querySelector(".version-list").querySelector(".info-table").getElementsByTagName("tr").forEach((version) => {
            if (version.attributes["data-language"]) {
                if (version.querySelector(".language-display")) {
                    versions[version.attributes["data-language"]] = []
                    languages.push([version.attributes["data-language"], version.querySelector(".language-display").text])
                }
                if (version.querySelector("span").querySelector("a")) {
                    link = version.querySelector("span").querySelector("a")
                    symbol = link.text.split(" (")[1].split(")")[0]
                    if (symbol.toUpperCase() === symbol && !(/\s/.test(symbol)) && isNaN(symbol)) {
                        versions[version.attributes["data-language"]].push([symbol, link.text.split(" (" + symbol)[0], link.attributes.href])
                    }
                }
            }
        })
        return versions[language]
    }
    const _download = async (data) => {
        result = {}
        progress = 0
        version = HTMLParser.parse((await axios.get("https://www.biblegateway.com" + data[2])).data)
        books = version.querySelector(".booklist-content").getElementsByTagName("tr")
        books.forEach((book) => {
            book.querySelector(".book-name").getElementsByTagName("span").forEach((span) => span.remove())
            title = book.querySelector(".book-name").text.split(" ").filter((text) => text.length > 0).join(" ")
            book.querySelector(".chapters").getElementsByTagName("a").forEach(async (chapter) => {
                chapter = [HTMLParser.parse((await axios.get("https://www.biblegateway.com" + chapter.attributes.href)).data), {}, chapter]
                chapter[0].querySelector(".passage-text").querySelector(".text-html").childNodes.forEach((item) => {
                    if (item.tagName && item.attributes.class !== "footnotes" && item.tagName !== "H3" && item.querySelector("span")) {
                        item.getElementsByTagName("span").filter((item) => item.attributes.class && item.attributes.class.includes("text ")).forEach((item) => {
                            if (item.querySelector(".chapternum")) item.querySelector(".chapternum").remove()
                            if (!chapter[1][parseInt(item.attributes.class.split("-").pop())]) {
                                chapter[1][parseInt(item.attributes.class.split("-").pop())] = []
                            }
                            item.getElementsByTagName("sup").forEach((sup) => sup.remove())
                            if (item.querySelector(".woj")) {
                                previous = item.text
                                woj = item.querySelectorAll(".woj").map((text) => (["woj", text.text]))
                                for (var text in woj) {
                                    text = [text, woj[text][1]]
                                    previous = previous.split(text[1]).join(`^^${text[0]}^^`)
                                }
                                previous = previous.split("^^").filter((text) => text.length > 0).map((text) => !isNaN(text) ? woj[parseInt(text)] : text)
                                chapter[1][parseInt(item.attributes.class.split("-").pop())].push(previous)
                            } else {
                                chapter[1][parseInt(item.attributes.class.split("-").pop())].push(item.text)
                            }
                            chapter[1][parseInt(item.attributes.class.split("-").pop())] = chapter[1][parseInt(item.attributes.class.split("-").pop())].filter((text) => (text !== null || text.length > 0))
                        })
                    }
                })
                chapter[0].querySelector(".passage-text").querySelector(".text-html").childNodes.forEach((item) => {
                    if (item.tagName && item.attributes.class && item.attributes.class !== "footnotes" && item.tagName === "H3") {
                        item = item.querySelector("span")
                        chapter[1][parseInt(item.attributes.class.split("-").pop())] = [["title", item.text]].concat(chapter[1][parseInt(item.attributes.class.split("-").pop())])
                        chapter[1][parseInt(item.attributes.class.split("-").pop())] = chapter[1][parseInt(item.attributes.class.split("-").pop())].filter((text) => (text !== null || text.length > 0))
                    }
                })
                if (!result[chapter[2].attributes.title.split(" ").slice(0, -1).join(" ")]) {
                    result[chapter[2].attributes.title.split(" ").slice(0, -1).join(" ")] = []
                }
                progress += 1
                counter = progress
                process.stdout.clearLine()
                process.stdout.cursorTo(0)
                process.stdout.write(`${data[0]} ${((progress/1189)*100).toFixed(2)}% ${chapter[2].attributes.title.split(" ").slice(0, -1).join(" ")} ${chapter[2].attributes.title.split(" ").pop()} `)
                result[chapter[2].attributes.title.split(" ").slice(0, -1).join(" ")].push([chapter[2].attributes.title.split(" ").pop(), Object.entries(chapter[1])])
                fs.writeFileSync("./bibles/" + data[0] + ".json", JSON.stringify(Object.entries(result)))
            })
        })
    }
    return {
        getVersions() {
            return _getVersions()
        },
        download(data) {
            return _download(data)
        }
    }
})()

if (!fs.existsSync("./bibles")) {
    fs.mkdirSync("./bibles")
}
(async () => {
    set = 0
    todownload = 0
    test = (await bible.getVersions()).filter((version) => (["NLT", "NKJV", "NIV", "AMP", "ASV", "ESV", "MSG", "AMPC"].includes(version[0])))
    id = setInterval(function(){
        if (set < test.length) {
            if (counter === 0 && !fs.existsSync(`./bibles/${test[set][0]}.json`) && set === todownload) {
                todownload += 1
                bible.download(test[set])
            } else if (counter > 1189-1) {
                set += 1
                counter = 0
                console.log("")
            }
        } else {
            clearInterval(id)
        }
    }, 1000)
})()